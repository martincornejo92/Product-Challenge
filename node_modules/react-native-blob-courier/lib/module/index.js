/**
 * Copyright (c) Ely Deckers.
 *
 * This source code is licensed under the MPL-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { NativeEventEmitter, NativeModules } from 'react-native';
import { BLOB_COURIER_PROGRESS_EVENT_NAME, BLOB_FETCH_FALLBACK_PARAMETERS, BLOB_MULTIPART_UPLOAD_FALLBACK_PARAMETERS, DEFAULT_FILE_MULTIPART_FIELD_NAME } from './Consts';
import './Extensions';
import { convertMappedMultipartsWithSymbolizedKeysToArray, sanitizeMappedMultiparts, uuid } from './Utils';
import { dict } from './Extensions';
const {
  BlobCourier,
  BlobCourierEventEmitter
} = NativeModules;
const EventEmitter = new NativeEventEmitter(BlobCourierEventEmitter);

const createTaskId = () => `rnbc-req-${uuid()}`;

const addProgressListener = (taskId, fn) => EventEmitter.addListener(BLOB_COURIER_PROGRESS_EVENT_NAME, e => {
  const parsedEvent = {
    written: parseInt(e.written, 10),
    total: parseInt(e.total, 10)
  };

  if (e.taskId === taskId) {
    fn(parsedEvent);
  }
});

const sanitizeSettingsData = input => {
  const {
    progressIntervalMilliseconds
  } = input;
  return {
    progressIntervalMilliseconds
  };
};

const sanitizeFetchData = input => {
  const {
    android,
    filename,
    headers,
    ios,
    method,
    mimeType,
    taskId,
    url
  } = input;
  const settings = sanitizeSettingsData(input);
  const request = {
    filename,
    mimeType,
    url
  };
  const optionalRequestParameters = dict({ ...settings,
    android,
    headers,
    ios,
    method
  }).fallback(BLOB_FETCH_FALLBACK_PARAMETERS);
  return { ...optionalRequestParameters,
    ...request,
    taskId
  };
};

const stringifyPartsValues = parts => {
  const stringify = part => part.type === 'string' && typeof part.payload === 'object' ? { ...part,
    payload: JSON.stringify(part.payload)
  } : part;

  return parts.map(stringify);
};

const sanitizeMultipartUploadData = input => {
  const {
    parts,
    headers,
    method,
    returnResponse,
    url
  } = input;
  const {
    taskId
  } = input;
  const settings = sanitizeSettingsData(input);
  const request = {
    mimeType: 'multipart/form-data',
    parts: stringifyPartsValues(parts),
    url
  };
  const optionalRequestParameters = dict({
    headers,
    method,
    returnResponse
  }).fallback(BLOB_MULTIPART_UPLOAD_FALLBACK_PARAMETERS);
  return { ...settings,
    ...optionalRequestParameters,
    ...request,
    taskId
  };
};

const wrapAbortListener = async (taskId, wrappedFn, signal) => {
  if (!signal) {
    return await wrappedFn();
  }

  const originalSignalOnAbort = signal.onabort; // @ts-ignore: TS2345

  signal.onabort = ev => {
    if (originalSignalOnAbort) {
      // @ts-ignore: TS2345
      originalSignalOnAbort.call(signal, ev);
    }

    BlobCourier.cancelRequest({
      taskId
    });
    console.debug(`Aborted ${taskId}`);
  };

  return await wrappedFn();
};

const wrapEmitter = async (taskId, wrappedFn, fnOnProgress) => {
  const emitterSubscription = fnOnProgress ? addProgressListener(taskId, fnOnProgress) : undefined;
  const result = await wrappedFn();
  emitterSubscription === null || emitterSubscription === void 0 ? void 0 : emitterSubscription.remove();
  return result;
};

const emitterWrappedFetch = input => wrapEmitter(input.taskId, () => BlobCourier.fetchBlob(sanitizeFetchData(input)), input.onProgress);

const emitterWrappedUpload = input => wrapEmitter(input.taskId, () => uploadBlobFromParts(input), input.onProgress);

const fetchBlob = input => wrapAbortListener(input.taskId, () => emitterWrappedFetch(input), input.signal);

const uploadBlobFromParts = input => {
  try {
    const sanitized = sanitizeMappedMultiparts(input.parts);
    return BlobCourier.uploadBlob(sanitizeMultipartUploadData({ ...input,
      parts: convertMappedMultipartsWithSymbolizedKeysToArray(sanitized)
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

const uploadParts = input => wrapAbortListener(input.taskId, () => emitterWrappedUpload(input), input.signal);

const uploadBlob = input => {
  const {
    absoluteFilePath,
    filename,
    mimeType,
    multipartName
  } = input;
  return uploadParts({ ...input,
    parts: {
      [multipartName ?? DEFAULT_FILE_MULTIPART_FIELD_NAME]: {
        payload: {
          absoluteFilePath,
          filename,
          mimeType
        },
        type: 'file'
      }
    }
  });
};

const onProgress = (taskId, fn, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  uploadBlob: input => uploadBlob({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  uploadParts: input => uploadParts({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(taskId, downloadManagerSettings, { ...requestSettings,
    onProgress: fn
  })
});

const useDownloadManagerOnAndroid = (taskId, downloadManagerSettings, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    android: {
      downloadManager: downloadManagerSettings,
      useDownloadManager: true
    },
    taskId
  })
});

const settings = (taskId, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    taskId
  }),
  onProgress: fn => onProgress(taskId, fn, requestSettings),
  uploadBlob: input => uploadBlob({ ...input,
    ...requestSettings,
    taskId
  }),
  uploadParts: input => uploadParts({ ...input,
    ...requestSettings,
    taskId
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(taskId, downloadManagerSettings, requestSettings)
});

export default {
  fetchBlob: input => fetchBlob({ ...input,
    taskId: createTaskId()
  }),
  onProgress: fn => onProgress(createTaskId(), fn),
  settings: input => settings(createTaskId(), input),
  uploadBlob: input => uploadBlob({ ...input,
    taskId: createTaskId()
  }),
  uploadParts: input => uploadParts({ ...input,
    taskId: createTaskId()
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(createTaskId(), downloadManagerSettings)
};
export * from './ExposedTypes';
export * from './ExposedConsts';
//# sourceMappingURL=index.js.map