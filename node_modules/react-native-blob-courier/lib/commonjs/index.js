"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {};
exports.default = void 0;

var _reactNative = require("react-native");

var _Consts = require("./Consts");

var _Extensions = require("./Extensions");

var _Utils = require("./Utils");

var _ExposedTypes = require("./ExposedTypes");

Object.keys(_ExposedTypes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _ExposedTypes[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ExposedTypes[key];
    }
  });
});

var _ExposedConsts = require("./ExposedConsts");

Object.keys(_ExposedConsts).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _ExposedConsts[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _ExposedConsts[key];
    }
  });
});

/**
 * Copyright (c) Ely Deckers.
 *
 * This source code is licensed under the MPL-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */
const {
  BlobCourier,
  BlobCourierEventEmitter
} = _reactNative.NativeModules;
const EventEmitter = new _reactNative.NativeEventEmitter(BlobCourierEventEmitter);

const createTaskId = () => `rnbc-req-${(0, _Utils.uuid)()}`;

const addProgressListener = (taskId, fn) => EventEmitter.addListener(_Consts.BLOB_COURIER_PROGRESS_EVENT_NAME, e => {
  const parsedEvent = {
    written: parseInt(e.written, 10),
    total: parseInt(e.total, 10)
  };

  if (e.taskId === taskId) {
    fn(parsedEvent);
  }
});

const sanitizeSettingsData = input => {
  const {
    progressIntervalMilliseconds
  } = input;
  return {
    progressIntervalMilliseconds
  };
};

const sanitizeFetchData = input => {
  const {
    android,
    filename,
    headers,
    ios,
    method,
    mimeType,
    taskId,
    url
  } = input;
  const settings = sanitizeSettingsData(input);
  const request = {
    filename,
    mimeType,
    url
  };
  const optionalRequestParameters = (0, _Extensions.dict)({ ...settings,
    android,
    headers,
    ios,
    method
  }).fallback(_Consts.BLOB_FETCH_FALLBACK_PARAMETERS);
  return { ...optionalRequestParameters,
    ...request,
    taskId
  };
};

const stringifyPartsValues = parts => {
  const stringify = part => part.type === 'string' && typeof part.payload === 'object' ? { ...part,
    payload: JSON.stringify(part.payload)
  } : part;

  return parts.map(stringify);
};

const sanitizeMultipartUploadData = input => {
  const {
    parts,
    headers,
    method,
    returnResponse,
    url
  } = input;
  const {
    taskId
  } = input;
  const settings = sanitizeSettingsData(input);
  const request = {
    mimeType: 'multipart/form-data',
    parts: stringifyPartsValues(parts),
    url
  };
  const optionalRequestParameters = (0, _Extensions.dict)({
    headers,
    method,
    returnResponse
  }).fallback(_Consts.BLOB_MULTIPART_UPLOAD_FALLBACK_PARAMETERS);
  return { ...settings,
    ...optionalRequestParameters,
    ...request,
    taskId
  };
};

const wrapAbortListener = async (taskId, wrappedFn, signal) => {
  if (!signal) {
    return await wrappedFn();
  }

  const originalSignalOnAbort = signal.onabort; // @ts-ignore: TS2345

  signal.onabort = ev => {
    if (originalSignalOnAbort) {
      // @ts-ignore: TS2345
      originalSignalOnAbort.call(signal, ev);
    }

    BlobCourier.cancelRequest({
      taskId
    });
    console.debug(`Aborted ${taskId}`);
  };

  return await wrappedFn();
};

const wrapEmitter = async (taskId, wrappedFn, fnOnProgress) => {
  const emitterSubscription = fnOnProgress ? addProgressListener(taskId, fnOnProgress) : undefined;
  const result = await wrappedFn();
  emitterSubscription === null || emitterSubscription === void 0 ? void 0 : emitterSubscription.remove();
  return result;
};

const emitterWrappedFetch = input => wrapEmitter(input.taskId, () => BlobCourier.fetchBlob(sanitizeFetchData(input)), input.onProgress);

const emitterWrappedUpload = input => wrapEmitter(input.taskId, () => uploadBlobFromParts(input), input.onProgress);

const fetchBlob = input => wrapAbortListener(input.taskId, () => emitterWrappedFetch(input), input.signal);

const uploadBlobFromParts = input => {
  try {
    const sanitized = (0, _Utils.sanitizeMappedMultiparts)(input.parts);
    return BlobCourier.uploadBlob(sanitizeMultipartUploadData({ ...input,
      parts: (0, _Utils.convertMappedMultipartsWithSymbolizedKeysToArray)(sanitized)
    }));
  } catch (e) {
    return Promise.reject(e);
  }
};

const uploadParts = input => wrapAbortListener(input.taskId, () => emitterWrappedUpload(input), input.signal);

const uploadBlob = input => {
  const {
    absoluteFilePath,
    filename,
    mimeType,
    multipartName
  } = input;
  return uploadParts({ ...input,
    parts: {
      [multipartName ?? _Consts.DEFAULT_FILE_MULTIPART_FIELD_NAME]: {
        payload: {
          absoluteFilePath,
          filename,
          mimeType
        },
        type: 'file'
      }
    }
  });
};

const onProgress = (taskId, fn, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  uploadBlob: input => uploadBlob({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  uploadParts: input => uploadParts({ ...input,
    ...requestSettings,
    onProgress: fn,
    taskId
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(taskId, downloadManagerSettings, { ...requestSettings,
    onProgress: fn
  })
});

const useDownloadManagerOnAndroid = (taskId, downloadManagerSettings, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    android: {
      downloadManager: downloadManagerSettings,
      useDownloadManager: true
    },
    taskId
  })
});

const settings = (taskId, requestSettings) => ({
  fetchBlob: input => fetchBlob({ ...input,
    ...requestSettings,
    taskId
  }),
  onProgress: fn => onProgress(taskId, fn, requestSettings),
  uploadBlob: input => uploadBlob({ ...input,
    ...requestSettings,
    taskId
  }),
  uploadParts: input => uploadParts({ ...input,
    ...requestSettings,
    taskId
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(taskId, downloadManagerSettings, requestSettings)
});

var _default = {
  fetchBlob: input => fetchBlob({ ...input,
    taskId: createTaskId()
  }),
  onProgress: fn => onProgress(createTaskId(), fn),
  settings: input => settings(createTaskId(), input),
  uploadBlob: input => uploadBlob({ ...input,
    taskId: createTaskId()
  }),
  uploadParts: input => uploadParts({ ...input,
    taskId: createTaskId()
  }),
  useDownloadManagerOnAndroid: downloadManagerSettings => useDownloadManagerOnAndroid(createTaskId(), downloadManagerSettings)
};
exports.default = _default;
//# sourceMappingURL=index.js.map